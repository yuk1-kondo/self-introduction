<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Foggy Window</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0a0a0a;
      --surface: #141414;
      --border: #222;
      --text: #fff;
      --text-muted: #666;
    }
    
    html, body { 
      background: var(--bg);
      color: var(--text); 
      font-family: 'Space Grotesk', system-ui, sans-serif;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }
    
    .app { 
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 32px;
      border-bottom: 1px solid var(--border);
    }
    
    .logo {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    
    .version {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 8px;
    }
    
    .controls {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px 32px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }
    
    .btn {
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      padding: 10px 18px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .btn:hover {
      background: var(--surface);
      border-color: #333;
    }
    
    .btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .btn-primary {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }
    
    .btn-primary:hover {
      opacity: 0.9;
      background: var(--text);
    }
    
    .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 8px;
    }
    
    .slider {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .slider-label {
      font-size: 12px;
      color: var(--text-muted);
      min-width: 40px;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      width: 60px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--text);
      border-radius: 50%;
      cursor: pointer;
    }
    
    .slider-value {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      min-width: 32px;
      font-variant-numeric: tabular-nums;
    }
    
    .stage { 
      flex: 1;
      display: grid; 
      place-items: center;
      padding: 24px;
      background: var(--bg);
      position: relative;
    }
    
    .canvas-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 0 1px var(--border);
    }
    
    canvas { display: block; }
    
    #fogCanvas, #effectCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    
    video { display: none; }
    
    .status { 
      position: fixed; 
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      padding: 12px 24px; 
      border-radius: 100px; 
      font-size: 13px;
      font-weight: 500;
      z-index: 100;
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .blow-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      z-index: 200;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .blow-indicator.active {
      opacity: 1;
      animation: blowPulse 0.5s ease-out;
    }
    
    @keyframes blowPulse {
      0% { transform: translate(-50%, -50%) scale(0.8); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 24px 40px;
      border-radius: 16px;
      font-size: 16px;
      font-weight: 500;
      z-index: 200;
      text-align: center;
      line-height: 1.8;
    }
    
    @media (max-width: 640px) {
      header { padding: 16px 20px; }
      .controls { padding: 12px 20px; gap: 6px; }
      .btn { padding: 8px 12px; font-size: 12px; }
      .slider { gap: 8px; }
      input[type="range"] { width: 50px; }
      .divider { display: none; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>

<body>
  <div class="app">
    <header>
      <div>
        <span class="logo">Foggy Window</span>
        <span class="version">v2.0</span>
      </div>
    </header>
    
    <div class="controls">
      <button id="btnStart" class="btn btn-primary">Start</button>
      <button id="btnClear" class="btn" disabled>Reset</button>
      <button id="btnFrost" class="btn" disabled>Add Frost ??</button>
      
      <span class="divider"></span>

      <div class="slider">
        <span class="slider-label">Fog</span>
        <input id="fogAmount" type="range" min="0" max="1" step="0.01" value="0.85" />
        <span id="fogVal" class="slider-value">0.85</span>
      </div>

      <div class="slider">
        <span class="slider-label">Fade</span>
        <input id="fadeSpeed" type="range" min="0" max="0.01" step="0.0005" value="0.001" />
        <span id="fadeVal" class="slider-value">0.001</span>
      </div>
    </div>

    <div id="hint" class="hint" style="display:none;">
      ?? Point finger = Draw<br>
      ?? Open palm = Wipe<br>
      ? Blow = Add fog
    </div>

    <div id="blowIndicator" class="blow-indicator">?</div>

    <div id="status" class="status" style="display:none;">
      <span id="statusText">Starting...</span>
    </div>

    <div class="stage">
      <video id="video" playsinline></video>
      <div class="canvas-container">
        <canvas id="videoCanvas"></canvas>
        <canvas id="fogCanvas"></canvas>
        <canvas id="effectCanvas"></canvas>
      </div>
    </div>
  </div>

<script>
(async () => {
  const video = document.getElementById('video');
  const videoCanvas = document.getElementById('videoCanvas');
  const fogCanvas = document.getElementById('fogCanvas');
  const effectCanvas = document.getElementById('effectCanvas');
  const btnStart = document.getElementById('btnStart');
  const btnClear = document.getElementById('btnClear');
  const btnFrost = document.getElementById('btnFrost');
  const hintEl = document.getElementById('hint');
  const statusEl = document.getElementById('status');
  const statusText = document.getElementById('statusText');
  const blowIndicator = document.getElementById('blowIndicator');

  const fogAmountEl = document.getElementById('fogAmount');
  const fadeSpeedEl = document.getElementById('fadeSpeed');
  const fogVal = document.getElementById('fogVal');
  const fadeVal = document.getElementById('fadeVal');

  const videoCtx = videoCanvas.getContext('2d');
  const fogCtx = fogCanvas.getContext('2d');
  const effectCtx = effectCanvas.getContext('2d');

  let W = 640, H = 480;
  let running = false;

  // Fog mask (0 = full fog, 1 = clear)
  let fogMask = null;
  
  // Water droplets
  let droplets = [];
  
  // Frost crystals
  let frostPatterns = [];
  let frostActive = false;

  function syncUI() {
    fogVal.textContent = (+fogAmountEl.value).toFixed(2);
    fadeVal.textContent = (+fadeSpeedEl.value).toFixed(3);
  }
  [fogAmountEl, fadeSpeedEl].forEach(el => el.addEventListener('input', syncUI));
  syncUI();

  function initFogMask() {
    fogMask = new Float32Array(W * H);
    fogMask.fill(0);
    droplets = [];
    frostPatterns = [];
    frostActive = false;
  }

  // ============ FOG MANIPULATION ============
  
  function wipeFog(x, y, radius, strength = 0.3) {
    const r2 = radius * radius;
    const ix = Math.floor(x);
    const iy = Math.floor(y);
    
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const px = ix + dx;
        const py = iy + dy;
        if (px < 0 || px >= W || py < 0 || py >= H) continue;
        
        const dist2 = dx * dx + dy * dy;
        if (dist2 < r2) {
          const softness = 1 - Math.sqrt(dist2) / radius;
          const idx = py * W + px;
          fogMask[idx] = Math.min(1, fogMask[idx] + softness * strength);
        }
      }
    }
  }

  function addFog(x, y, radius, strength = 0.15) {
    const r2 = radius * radius;
    const ix = Math.floor(x);
    const iy = Math.floor(y);
    
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const px = ix + dx;
        const py = iy + dy;
        if (px < 0 || px >= W || py < 0 || py >= H) continue;
        
        const dist2 = dx * dx + dy * dy;
        if (dist2 < r2) {
          const softness = 1 - Math.sqrt(dist2) / radius;
          const idx = py * W + px;
          fogMask[idx] = Math.max(0, fogMask[idx] - softness * strength);
        }
      }
    }
  }

  function fadeFog() {
    const fadeSpeed = +fadeSpeedEl.value;
    if (fadeSpeed <= 0) return;
    
    for (let i = 0; i < fogMask.length; i++) {
      if (fogMask[i] > 0) {
        fogMask[i] = Math.max(0, fogMask[i] - fadeSpeed);
      }
    }
  }

  // ============ WATER DROPLETS ============
  
  function spawnDroplet() {
    if (droplets.length > 30) return;
    
    droplets.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.3,
      size: Math.random() * 8 + 4,
      speed: Math.random() * 0.5 + 0.3,
      wobble: Math.random() * Math.PI * 2
    });
  }

  function updateDroplets() {
    for (let i = droplets.length - 1; i >= 0; i--) {
      const d = droplets[i];
      
      // Move down with slight wobble
      d.y += d.speed;
      d.wobble += 0.1;
      d.x += Math.sin(d.wobble) * 0.3;
      
      // Wipe fog as droplet moves
      wipeFog(d.x, d.y, d.size * 0.5, 0.5);
      
      // Grow slightly as it collects moisture
      d.size += 0.01;
      d.speed += 0.01;
      
      // Remove if off screen
      if (d.y > H + 20) {
        droplets.splice(i, 1);
      }
    }
    
    // Random spawn
    if (Math.random() < 0.02) {
      spawnDroplet();
    }
  }

  function renderDroplets() {
    for (const d of droplets) {
      // Water droplet with refraction effect
      const gradient = effectCtx.createRadialGradient(
        d.x - d.size * 0.3, d.y - d.size * 0.3, 0,
        d.x, d.y, d.size
      );
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.4)');
      gradient.addColorStop(1, 'rgba(150, 180, 220, 0.1)');
      
      effectCtx.beginPath();
      effectCtx.ellipse(d.x, d.y, d.size * 0.7, d.size, 0, 0, Math.PI * 2);
      effectCtx.fillStyle = gradient;
      effectCtx.fill();
      
      // Highlight
      effectCtx.beginPath();
      effectCtx.arc(d.x - d.size * 0.2, d.y - d.size * 0.3, d.size * 0.2, 0, Math.PI * 2);
      effectCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      effectCtx.fill();
    }
  }

  // ============ FROST PATTERNS ============
  
  function generateFrost() {
    frostPatterns = [];
    frostActive = true;
    
    // Generate frost from edges
    const numBranches = 20;
    
    for (let i = 0; i < numBranches; i++) {
      let startX, startY, angle;
      const edge = Math.floor(Math.random() * 4);
      
      switch(edge) {
        case 0: // top
          startX = Math.random() * W;
          startY = 0;
          angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          break;
        case 1: // bottom
          startX = Math.random() * W;
          startY = H;
          angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          break;
        case 2: // left
          startX = 0;
          startY = Math.random() * H;
          angle = (Math.random() - 0.5) * 0.5;
          break;
        case 3: // right
          startX = W;
          startY = Math.random() * H;
          angle = Math.PI + (Math.random() - 0.5) * 0.5;
          break;
      }
      
      generateFrostBranch(startX, startY, angle, 80 + Math.random() * 60, 3);
    }
    
    // Corner frost (denser)
    const corners = [[0, 0], [W, 0], [0, H], [W, H]];
    for (const [cx, cy] of corners) {
      for (let j = 0; j < 8; j++) {
        const angle = Math.atan2(H/2 - cy, W/2 - cx) + (Math.random() - 0.5) * 1.5;
        generateFrostBranch(cx, cy, angle, 60 + Math.random() * 80, 3);
      }
    }
  }

  function generateFrostBranch(x, y, angle, length, depth) {
    if (depth <= 0 || length < 5) return;
    
    const segments = Math.floor(length / 5);
    let px = x, py = y;
    
    for (let i = 0; i < segments; i++) {
      const segLen = 3 + Math.random() * 4;
      const nx = px + Math.cos(angle) * segLen;
      const ny = py + Math.sin(angle) * segLen;
      
      frostPatterns.push({
        x1: px, y1: py,
        x2: nx, y2: ny,
        width: depth * 0.8,
        opacity: 0.3 + depth * 0.15
      });
      
      // Sub-branches
      if (Math.random() < 0.3 && depth > 1) {
        const branchAngle = angle + (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.5);
        generateFrostBranch(nx, ny, branchAngle, length * 0.5, depth - 1);
      }
      
      px = nx;
      py = ny;
      angle += (Math.random() - 0.5) * 0.3;
    }
  }

  function renderFrost() {
    if (!frostActive) return;
    
    effectCtx.lineCap = 'round';
    
    for (const f of frostPatterns) {
      effectCtx.beginPath();
      effectCtx.moveTo(f.x1, f.y1);
      effectCtx.lineTo(f.x2, f.y2);
      effectCtx.strokeStyle = `rgba(220, 240, 255, ${f.opacity})`;
      effectCtx.lineWidth = f.width;
      effectCtx.stroke();
      
      // Add sparkle
      if (Math.random() < 0.01) {
        effectCtx.beginPath();
        effectCtx.arc(f.x2, f.y2, 2, 0, Math.PI * 2);
        effectCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        effectCtx.fill();
      }
    }
  }

  // ============ FOG RENDERING ============
  
  // Pre-generate noise texture
  let noiseData = null;
  function generateNoiseTexture() {
    const size = W * H * 4;
    noiseData = new Uint8ClampedArray(size);
    for (let i = 0; i < size; i += 4) {
      const v = Math.random() * 30;
      noiseData[i] = 255;
      noiseData[i+1] = 255;
      noiseData[i+2] = 255;
      noiseData[i+3] = v;
    }
  }

  function renderFog() {
    const fogAmount = +fogAmountEl.value;
    
    fogCtx.clearRect(0, 0, W, H);
    
    // Draw blurred version as fog base
    fogCtx.filter = 'blur(10px)';
    fogCtx.globalAlpha = fogAmount;
    fogCtx.drawImage(videoCanvas, 0, 0);
    fogCtx.filter = 'none';
    
    // Add white overlay
    fogCtx.globalAlpha = fogAmount * 0.55;
    fogCtx.fillStyle = '#e8f0ff';
    fogCtx.fillRect(0, 0, W, H);
    
    // Add noise texture
    if (noiseData) {
      fogCtx.globalAlpha = fogAmount * 0.2;
      const imgData = new ImageData(noiseData, W, H);
      fogCtx.putImageData(imgData, 0, 0);
    }
    
    fogCtx.globalAlpha = 1;
    
    // Apply fog mask (cut out wiped areas)
    const imageData = fogCtx.getImageData(0, 0, W, H);
    const data = imageData.data;
    
    for (let i = 0; i < fogMask.length; i++) {
      const clearness = fogMask[i];
      if (clearness > 0) {
        const alphaIdx = i * 4 + 3;
        data[alphaIdx] = Math.floor(data[alphaIdx] * (1 - clearness));
      }
    }
    
    fogCtx.putImageData(imageData, 0, 0);
  }

  // ============ HAND DETECTION ============
  
  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.5
  });

  let lastFingerPos = null;
  let lastPalmPos = null;

  function isFingerExtended(landmarks, tipIdx, pipIdx, mcpIdx) {
    const tip = landmarks[tipIdx];
    const pip = landmarks[pipIdx];
    const mcp = landmarks[mcpIdx];
    const tipAbovePip = (pip.y - tip.y) > 0.03;
    const pipAboveMcp = (mcp.y - pip.y) > 0.01;
    return tipAbovePip && pipAboveMcp;
  }
  
  function isFingerFolded(landmarks, tipIdx, pipIdx, mcpIdx) {
    const tip = landmarks[tipIdx];
    const pip = landmarks[pipIdx];
    return (tip.y - pip.y) > -0.02;
  }
  
  function isOnlyIndexFingerUp(landmarks) {
    const indexUp = isFingerExtended(landmarks, 8, 6, 5);
    const middleFolded = isFingerFolded(landmarks, 12, 10, 9);
    const ringFolded = isFingerFolded(landmarks, 16, 14, 13);
    const pinkyFolded = isFingerFolded(landmarks, 20, 18, 17);
    return indexUp && middleFolded && ringFolded && pinkyFolded;
  }
  
  function isOpenPalm(landmarks) {
    const indexUp = isFingerExtended(landmarks, 8, 6, 5);
    const middleUp = isFingerExtended(landmarks, 12, 10, 9);
    const ringUp = isFingerExtended(landmarks, 16, 14, 13);
    const pinkyUp = isFingerExtended(landmarks, 20, 18, 17);
    return indexUp && middleUp && ringUp && pinkyUp;
  }
  
  function getPalmCenter(landmarks) {
    // Average of wrist (0), index mcp (5), pinky mcp (17)
    const pts = [landmarks[0], landmarks[5], landmarks[17], landmarks[9], landmarks[13]];
    let x = 0, y = 0;
    for (const p of pts) { x += p.x; y += p.y; }
    return { x: (1 - x / pts.length) * W, y: (y / pts.length) * H };
  }
  
  hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      const landmarks = results.multiHandLandmarks[0];
      
      const tip = landmarks[8];
      const fingerTip = { x: (1 - tip.x) * W, y: tip.y * H };
      const palmCenter = getPalmCenter(landmarks);
      
      if (isOpenPalm(landmarks)) {
        // Open palm = wipe with large brush
        statusText.textContent = '?? Wiping...';
        const wipeRadius = 80;
        wipeFog(palmCenter.x, palmCenter.y, wipeRadius, 0.4);
        
        if (lastPalmPos) {
          const dx = palmCenter.x - lastPalmPos.x;
          const dy = palmCenter.y - lastPalmPos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const steps = Math.ceil(dist / 10);
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            wipeFog(lastPalmPos.x + dx * t, lastPalmPos.y + dy * t, wipeRadius, 0.4);
          }
        }
        lastPalmPos = { ...palmCenter };
        lastFingerPos = null;
        
      } else if (isOnlyIndexFingerUp(landmarks)) {
        // Index finger = draw
        statusText.textContent = '?? Drawing...';
        const brushRadius = 25;
        wipeFog(fingerTip.x, fingerTip.y, brushRadius, 0.4);
        
        if (lastFingerPos) {
          const dx = fingerTip.x - lastFingerPos.x;
          const dy = fingerTip.y - lastFingerPos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const steps = Math.ceil(dist / 5);
          for (let i = 0; i < steps; i++) {
            const t = i / steps;
            wipeFog(lastFingerPos.x + dx * t, lastFingerPos.y + dy * t, brushRadius, 0.4);
          }
        }
        lastFingerPos = { ...fingerTip };
        lastPalmPos = null;
        
      } else {
        statusText.textContent = '?? Point or ?? Palm';
        lastFingerPos = null;
        lastPalmPos = null;
      }
    } else {
      lastFingerPos = null;
      lastPalmPos = null;
    }
  });

  // ============ FACE DETECTION (BLOW) ============
  
  const faceMesh = new FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  
  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  let isBlowing = false;
  let blowCooldown = 0;
  
  faceMesh.onResults((results) => {
    if (blowCooldown > 0) {
      blowCooldown--;
      return;
    }
    
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      const landmarks = results.multiFaceLandmarks[0];
      
      // Lip landmarks for detecting "blow" mouth shape
      // Upper lip: 13, Lower lip: 14
      // Left corner: 61, Right corner: 291
      // Upper outer: 0, Lower outer: 17
      
      const upperLip = landmarks[13];
      const lowerLip = landmarks[14];
      const leftCorner = landmarks[61];
      const rightCorner = landmarks[291];
      
      // Mouth opening (vertical)
      const mouthOpen = Math.abs(lowerLip.y - upperLip.y);
      
      // Mouth width
      const mouthWidth = Math.abs(rightCorner.x - leftCorner.x);
      
      // Blow detection: mouth is slightly open and pursed (narrow width)
      const isPursed = mouthWidth < 0.08;
      const isSlightlyOpen = mouthOpen > 0.01 && mouthOpen < 0.05;
      
      if (isPursed && isSlightlyOpen) {
        if (!isBlowing) {
          isBlowing = true;
          blowIndicator.classList.add('active');
          statusText.textContent = '? Blowing!';
          
          // Add fog around mouth area
          const mouthX = (1 - (leftCorner.x + rightCorner.x) / 2) * W;
          const mouthY = ((upperLip.y + lowerLip.y) / 2) * H;
          
          // Blow fog outward from mouth
          for (let angle = -1; angle <= 1; angle += 0.2) {
            for (let dist = 50; dist < 200; dist += 20) {
              const x = mouthX + Math.cos(angle) * dist;
              const y = mouthY + dist * 0.5;
              addFog(x, y, 40 + dist * 0.2, 0.1);
            }
          }
          
          blowCooldown = 30; // Cooldown frames
          
          setTimeout(() => {
            blowIndicator.classList.remove('active');
            isBlowing = false;
          }, 500);
        }
      }
    }
  });

  // ============ MAIN LOOP ============
  
  async function start() {
    if (running) return;
    
    btnStart.disabled = true;
    btnStart.textContent = 'Loading...';
    
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } },
      audio: false
    });
    
    video.srcObject = stream;
    await video.play();
    
    W = video.videoWidth;
    H = video.videoHeight;
    
    videoCanvas.width = W;
    videoCanvas.height = H;
    fogCanvas.width = W;
    fogCanvas.height = H;
    effectCanvas.width = W;
    effectCanvas.height = H;
    
    initFogMask();
    generateNoiseTexture();
    
    running = true;
    btnStart.textContent = 'Running';
    btnClear.disabled = false;
    btnFrost.disabled = false;
    statusEl.style.display = 'flex';
    hintEl.style.display = 'block';
    
    setTimeout(() => { hintEl.style.display = 'none'; }, 5000);
    
    loop();
  }

  let frameCount = 0;
  
  async function loop() {
    if (!running) return;
    
    frameCount++;
    
    // Draw video (flipped)
    videoCtx.save();
    videoCtx.scale(-1, 1);
    videoCtx.drawImage(video, -W, 0, W, H);
    videoCtx.restore();
    
    // Process detections (alternate to save performance)
    if (frameCount % 2 === 0) {
      await hands.send({ image: video });
    } else {
      await faceMesh.send({ image: video });
    }
    
    // Update effects
    fadeFog();
    updateDroplets();
    
    // Render layers
    renderFog();
    
    effectCtx.clearRect(0, 0, W, H);
    renderDroplets();
    renderFrost();
    
    requestAnimationFrame(loop);
  }

  btnStart.addEventListener('click', start);
  btnClear.addEventListener('click', () => { initFogMask(); });
  btnFrost.addEventListener('click', () => { generateFrost(); });
})();
</script>
</body>
</html>
