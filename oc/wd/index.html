<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Rain Effect - Codrops Style</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    video { display: none; }
    canvas { display: block; }
    #glCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: #fff;
    }
    .spinner {
      width: 40px; height: 40px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loading p { margin-top: 16px; opacity: 0.7; }
    
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      padding: 12px 20px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .btn {
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .btn:hover { background: rgba(255,255,255,0.25); }
    .btn.active { background: rgba(255,255,255,0.3); }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-size: 12px;
    }
    .slider-container input[type="range"] {
      width: 80px;
      -webkit-appearance: none;
      background: rgba(255,255,255,0.2);
      height: 4px;
      border-radius: 2px;
    }
    .slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 14px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <p>初期化中...</p>
  </div>
  
  <div id="container">
    <video id="video" playsinline></video>
    <canvas id="glCanvas"></canvas>
  </div>
  
  <div class="controls">
    <div class="slider-container">
      <span>?</span>
      <input type="range" id="rainAmount" min="0" max="100" value="50">
    </div>
    <button class="btn" id="toggleRain">? 停止</button>
    <button class="btn" id="clearBtn">? クリア</button>
  </div>

  <!-- Vertex Shader -->
  <script id="vert-shader" type="x-shader/x-vertex">
    precision mediump float;
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  </script>

  <!-- Fragment Shader - Based on Codrops water.frag -->
  <script id="frag-shader" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform sampler2D u_waterMap;
    uniform sampler2D u_textureFg;
    uniform sampler2D u_textureBg;
    
    varying vec2 v_texCoord;
    uniform vec2 u_resolution;
    uniform float u_minRefraction;
    uniform float u_refractionDelta;
    uniform float u_brightness;
    uniform float u_alphaMultiply;
    uniform float u_alphaSubtract;
    
    vec2 texCoord() {
      return vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y) / u_resolution;
    }
    
    vec2 pixel() {
      return vec2(1.0, 1.0) / u_resolution;
    }
    
    // Alpha blend two colors
    vec4 blend(vec4 bg, vec4 fg) {
      vec3 bgm = bg.rgb * bg.a;
      vec3 fgm = fg.rgb * fg.a;
      float ia = 1.0 - fg.a;
      float a = fg.a + bg.a * ia;
      vec3 rgb;
      if (a != 0.0) {
        rgb = (fgm + bgm * ia) / a;
      } else {
        rgb = vec3(0.0);
      }
      return vec4(rgb, a);
    }
    
    void main() {
      vec2 uv = texCoord();
      
      // Background (blurred camera)
      vec4 bg = texture2D(u_textureBg, uv);
      
      // Water map - RGB encodes refraction direction
      vec4 cur = texture2D(u_waterMap, uv);
      
      float d = cur.b; // depth/thickness
      float x = cur.g; // x distortion (0.5 = center)
      float y = cur.r; // y distortion (0.5 = center)
      
      // Alpha based on gooey effect
      float a = clamp(cur.a * u_alphaMultiply - u_alphaSubtract, 0.0, 1.0);
      
      // Refraction offset
      vec2 refraction = (vec2(x, y) - 0.5) * 2.0;
      vec2 refractionPos = uv + pixel() * refraction * (u_minRefraction + d * u_refractionDelta);
      
      // Foreground through refraction (clear camera)
      vec4 tex = texture2D(u_textureFg, refractionPos);
      
      vec4 fg = vec4(tex.rgb * u_brightness, a);
      
      gl_FragColor = blend(bg, fg);
    }
  </script>

  <script>
    // ============================================================
    // Rain Effect - Faithful Codrops Implementation
    // Based on https://github.com/codrops/RainEffect
    // ============================================================
    
    // Codrops drop images embedded as Base64 (avoids CORS issues)
    const DROP_COLOR_BASE64 = 'data:image/png;base64,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';
    
    const DROP_ALPHA_BASE64 = 'data:image/png;base64,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';
    
    const video = document.getElementById('video');
    const glCanvas = document.getElementById('glCanvas');
    const loading = document.getElementById('loading');
    
    let gl;
    let program;
    let width, height;
    let dpi = window.devicePixelRatio || 1;
    
    // Textures
    let waterMapTexture, fgTexture, bgTexture;
    let raindrops;
    
    // Drop images from Codrops (essential for realism)
    let dropColorImg, dropAlphaImg;
    
    // Settings
    let isRaining = true;
    let rainIntensity = 0.5;
    
    // ============================================================
    // Drop object prototype (from Codrops)
    // ============================================================
    const Drop = {
      x: 0,
      y: 0,
      r: 0,
      spreadX: 0,
      spreadY: 0,
      momentum: 0,
      momentumX: 0,
      lastSpawn: 0,
      nextSpawn: 0,
      parent: null,
      isNew: true,
      killed: false,
      shrink: 0
    };
    
    // ============================================================
    // Raindrops Class (from Codrops raindrops.js)
    // ============================================================
    class Raindrops {
      constructor(w, h, scale, dropAlpha, dropColor, options = {}) {
        this.width = w;
        this.height = h;
        this.scale = scale;
        this.dropAlpha = dropAlpha;
        this.dropColor = dropColor;
        this.scale = scale;
        
        this.options = Object.assign({
          minR: 10,
          maxR: 40,
          maxDrops: 900,
          rainChance: 0.3,
          rainLimit: 3,
          dropletsRate: 50,
          dropletsSize: [2, 4],
          dropletsCleaningRadiusMultiplier: 0.43,
          raining: true,
          globalTimeScale: 1,
          trailRate: 1,
          autoShrink: true,
          spawnArea: [-0.1, 0.95],
          trailScaleRange: [0.2, 0.5],
          collisionRadius: 0.65,
          collisionRadiusIncrease: 0.01,
          dropFallMultiplier: 1,
          collisionBoostMultiplier: 0.05,
          collisionBoost: 1
        }, options);
        
        this.drops = [];
        this.dropletsPixelDensity = 1;
        this.dropletsCounter = 0;
        this.textureCleaningIterations = 0;
        this.lastRender = null;
        
        this.init();
      }
      
      get deltaR() {
        return this.options.maxR - this.options.minR;
      }
      
      get area() {
        return (this.width * this.height) / this.scale;
      }
      
      get areaMultiplier() {
        return Math.sqrt(this.area / (1024 * 768));
      }
      
      init() {
        // Main canvas for drops
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.ctx = this.canvas.getContext('2d');
        
        // Small droplets canvas
        this.droplets = document.createElement('canvas');
        this.droplets.width = this.width * this.dropletsPixelDensity;
        this.droplets.height = this.height * this.dropletsPixelDensity;
        this.dropletsCtx = this.droplets.getContext('2d');
        
        // Pre-render drop graphics using Codrops images
        this.renderDropsGfx();
      }
      
      // Render drop graphics with REAL Codrops technique
      // Uses drop-color.png and drop-alpha.png for proper normal-mapping effect
      renderDropsGfx() {
        const dropSize = 64;
        this.dropsGfx = [];
        
        // Create buffer canvas for compositing
        const dropBuffer = document.createElement('canvas');
        dropBuffer.width = dropSize;
        dropBuffer.height = dropSize;
        const dropBufferCtx = dropBuffer.getContext('2d');
        
        // Generate 255 drop graphics with varying depth values
        for (let i = 0; i < 255; i++) {
          const drop = document.createElement('canvas');
          drop.width = dropSize;
          drop.height = dropSize;
          const dropCtx = drop.getContext('2d');
          
          // Clear buffer
          dropBufferCtx.clearRect(0, 0, dropSize, dropSize);
          
          // Step 1: Draw drop-color.png (contains refraction direction in RGB)
          dropBufferCtx.globalCompositeOperation = 'source-over';
          dropBufferCtx.drawImage(this.dropColor, 0, 0, dropSize, dropSize);
          
          // Step 2: Add blue overlay for depth (Codrops original technique)
          // The blue channel encodes the depth/thickness of the drop
          dropBufferCtx.globalCompositeOperation = 'screen';
          dropBufferCtx.fillStyle = `rgba(0, 0, ${i}, 1)`;
          dropBufferCtx.fillRect(0, 0, dropSize, dropSize);
          
          // Step 3: Draw drop-alpha.png as the alpha mask
          dropCtx.globalCompositeOperation = 'source-over';
          dropCtx.drawImage(this.dropAlpha, 0, 0, dropSize, dropSize);
          
          // Step 4: Apply the colored buffer using source-in (keeps only overlapping areas)
          dropCtx.globalCompositeOperation = 'source-in';
          dropCtx.drawImage(dropBuffer, 0, 0, dropSize, dropSize);
          
          this.dropsGfx.push(drop);
        }
        
        // Create circle graphic for clearing droplets
        this.clearDropletsGfx = document.createElement('canvas');
        this.clearDropletsGfx.width = 128;
        this.clearDropletsGfx.height = 128;
        const clearCtx = this.clearDropletsGfx.getContext('2d');
        clearCtx.fillStyle = '#000';
        clearCtx.beginPath();
        clearCtx.arc(64, 64, 64, 0, Math.PI * 2);
        clearCtx.fill();
      }
      
      drawDroplet(x, y, r) {
        // Draw small droplets with proper normal-mapping colors
        const ctx = this.dropletsCtx;
        const px = x * this.dropletsPixelDensity;
        const py = y * this.dropletsPixelDensity;
        const pr = r * this.dropletsPixelDensity;
        
        // Use random depth for droplets
        const depthIndex = Math.floor(Math.random() * 128) + 50;
        if (this.dropsGfx.length > 0 && this.dropsGfx[depthIndex]) {
          ctx.drawImage(this.dropsGfx[depthIndex], px - pr, py - pr, pr * 2, pr * 2);
        }
      }
      
      drawDrop(ctx, drop) {
        if (this.dropsGfx.length === 0) return;
        
        const x = drop.x;
        const y = drop.y;
        const r = drop.r;
        const spreadX = drop.spreadX;
        const spreadY = drop.spreadY;
        
        const scaleX = 1;
        const scaleY = 1.5;
        
        let d = Math.max(0, Math.min(1, ((r - this.options.minR) / this.deltaR) * 0.9));
        d *= 1 / (((spreadX + spreadY) * 0.5) + 1);
        d = Math.floor(d * (this.dropsGfx.length - 1));
        
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
        
        ctx.drawImage(
          this.dropsGfx[d],
          (x - r * scaleX * (spreadX + 1)) * this.scale,
          (y - r * scaleY * (spreadY + 1)) * this.scale,
          r * 2 * scaleX * (spreadX + 1) * this.scale,
          r * 2 * scaleY * (spreadY + 1) * this.scale
        );
      }
      
      clearDroplets(x, y, r = 30) {
        const ctx = this.dropletsCtx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.drawImage(
          this.clearDropletsGfx,
          (x - r) * this.dropletsPixelDensity * this.scale,
          (y - r) * this.dropletsPixelDensity * this.scale,
          r * 2 * this.dropletsPixelDensity * this.scale,
          r * 2 * this.dropletsPixelDensity * this.scale * 1.5
        );
        ctx.globalCompositeOperation = 'source-over';
      }
      
      clearCanvas() {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }
      
      createDrop(options) {
        if (this.drops.length >= this.options.maxDrops * this.areaMultiplier) return null;
        return Object.assign(Object.create(Drop), options);
      }
      
      addDrop(drop) {
        if (this.drops.length >= this.options.maxDrops * this.areaMultiplier || drop === null) return false;
        this.drops.push(drop);
        return true;
      }
      
      updateRain(timeScale) {
        const rainDrops = [];
        if (this.options.raining) {
          const limit = this.options.rainLimit * timeScale * this.areaMultiplier;
          let count = 0;
          
          while (Math.random() < this.options.rainChance * timeScale * this.areaMultiplier && count < limit) {
            count++;
            const r = this.random(this.options.minR, this.options.maxR, n => Math.pow(n, 3));
            const rainDrop = this.createDrop({
              x: Math.random() * this.width / this.scale,
              y: this.random(
                (this.height / this.scale) * this.options.spawnArea[0],
                (this.height / this.scale) * this.options.spawnArea[1]
              ),
              r: r,
              momentum: 1 + ((r - this.options.minR) * 0.1) + Math.random() * 2,
              spreadX: 1.5,
              spreadY: 1.5
            });
            if (rainDrop !== null) {
              rainDrops.push(rainDrop);
            }
          }
        }
        return rainDrops;
      }
      
      random(from, to, interpolation) {
        if (interpolation === undefined) {
          return from + Math.random() * (to - from);
        }
        return from + interpolation(Math.random()) * (to - from);
      }
      
      clearDrops() {
        this.drops.forEach(drop => {
          setTimeout(() => {
            drop.shrink = 0.1 + Math.random() * 0.5;
          }, Math.random() * 1200);
        });
        this.textureCleaningIterations = 50;
      }
      
      updateDroplets(timeScale) {
        // Clean droplets gradually
        if (this.textureCleaningIterations > 0) {
          this.textureCleaningIterations -= 1 * timeScale;
          this.dropletsCtx.globalCompositeOperation = 'destination-out';
          this.dropletsCtx.fillStyle = `rgba(0,0,0,${0.05 * timeScale})`;
          this.dropletsCtx.fillRect(0, 0, this.droplets.width, this.droplets.height);
          this.dropletsCtx.globalCompositeOperation = 'source-over';
        }
        
        // Add new droplets
        if (this.options.raining) {
          this.dropletsCounter += this.options.dropletsRate * timeScale * this.areaMultiplier;
          while (this.dropletsCounter >= 1) {
            this.dropletsCounter--;
            this.drawDroplet(
              Math.random() * this.width / this.scale,
              Math.random() * this.height / this.scale,
              this.random(this.options.dropletsSize[0], this.options.dropletsSize[1], n => n * n)
            );
          }
        }
        
        // Draw droplets to main canvas
        this.ctx.drawImage(this.droplets, 0, 0, this.width, this.height);
      }
      
      updateDrops(timeScale) {
        let newDrops = [];
        
        this.updateDroplets(timeScale);
        const rainDrops = this.updateRain(timeScale);
        newDrops = newDrops.concat(rainDrops);
        
        // Sort drops by position
        this.drops.sort((a, b) => {
          const va = (a.y * (this.width / this.scale)) + a.x;
          const vb = (b.y * (this.width / this.scale)) + b.x;
          return va > vb ? 1 : va === vb ? 0 : -1;
        });
        
        this.drops.forEach((drop, i) => {
          if (!drop.killed) {
            // Gravity - chance of drops creeping down
            if (Math.random() < (drop.r - this.options.minR * this.options.dropFallMultiplier) * (0.1 / this.deltaR) * timeScale) {
              drop.momentum += Math.random() * (drop.r / this.options.maxR) * 4;
            }
            
            // Auto shrink small drops
            if (this.options.autoShrink && drop.r <= this.options.minR && Math.random() < 0.05 * timeScale) {
              drop.shrink += 0.01;
            }
            
            // Update shrinkage
            drop.r -= drop.shrink * timeScale;
            if (drop.r <= 0) drop.killed = true;
            
            // Update trails
            if (this.options.raining) {
              drop.lastSpawn += drop.momentum * timeScale * this.options.trailRate;
              if (drop.lastSpawn > drop.nextSpawn) {
                const trailDrop = this.createDrop({
                  x: drop.x + this.random(-drop.r, drop.r) * 0.1,
                  y: drop.y - drop.r * 0.01,
                  r: drop.r * this.random(this.options.trailScaleRange[0], this.options.trailScaleRange[1]),
                  spreadY: drop.momentum * 0.1,
                  parent: drop
                });
                
                if (trailDrop !== null) {
                  newDrops.push(trailDrop);
                  drop.r *= Math.pow(0.97, timeScale);
                  drop.lastSpawn = 0;
                  drop.nextSpawn = this.random(this.options.minR, this.options.maxR) - 
                    drop.momentum * 2 * this.options.trailRate + (this.options.maxR - drop.r);
                }
              }
            }
            
            // Normalize spread
            drop.spreadX *= Math.pow(0.4, timeScale);
            drop.spreadY *= Math.pow(0.7, timeScale);
            
            // Update position
            const moved = drop.momentum > 0;
            if (moved && !drop.killed) {
              drop.y += drop.momentum * this.options.globalTimeScale;
              drop.x += drop.momentumX * this.options.globalTimeScale;
              if (drop.y > this.height / this.scale + drop.r) {
                drop.killed = true;
              }
            }
            
            // Collision detection
            const checkCollision = (moved || drop.isNew) && !drop.killed;
            drop.isNew = false;
            
            if (checkCollision) {
              this.drops.slice(i + 1, i + 70).forEach(drop2 => {
                if (drop !== drop2 && drop.r > drop2.r && 
                    drop.parent !== drop2 && drop2.parent !== drop && !drop2.killed) {
                  const dx = drop2.x - drop.x;
                  const dy = drop2.y - drop.y;
                  const d = Math.sqrt(dx * dx + dy * dy);
                  
                  if (d < (drop.r + drop2.r) * (this.options.collisionRadius + drop.momentum * this.options.collisionRadiusIncrease * timeScale)) {
                    const r1 = drop.r;
                    const r2 = drop2.r;
                    const a1 = Math.PI * r1 * r1;
                    const a2 = Math.PI * r2 * r2;
                    let targetR = Math.sqrt((a1 + a2 * 0.8) / Math.PI);
                    if (targetR > this.options.maxR) targetR = this.options.maxR;
                    
                    drop.r = targetR;
                    drop.momentumX += dx * 0.1;
                    drop.spreadX = 0;
                    drop.spreadY = 0;
                    drop2.killed = true;
                    drop.momentum = Math.max(drop2.momentum, Math.min(40,
                      drop.momentum + targetR * this.options.collisionBoostMultiplier + this.options.collisionBoost
                    ));
                  }
                }
              });
            }
            
            // Slowdown momentum
            drop.momentum -= Math.max(1, (this.options.minR * 0.5) - drop.momentum) * 0.1 * timeScale;
            if (drop.momentum < 0) drop.momentum = 0;
            drop.momentumX *= Math.pow(0.7, timeScale);
            
            if (!drop.killed) {
              newDrops.push(drop);
              if (moved && this.options.dropletsRate > 0) {
                this.clearDroplets(drop.x, drop.y, drop.r * this.options.dropletsCleaningRadiusMultiplier);
              }
              this.drawDrop(this.ctx, drop);
            }
          }
        });
        
        this.drops = newDrops;
      }
      
      update() {
        this.clearCanvas();
        
        const now = Date.now();
        if (this.lastRender === null) this.lastRender = now;
        let deltaT = now - this.lastRender;
        let timeScale = deltaT / ((1 / 60) * 1000);
        if (timeScale > 1.1) timeScale = 1.1;
        timeScale *= this.options.globalTimeScale;
        this.lastRender = now;
        
        this.updateDrops(timeScale);
      }
    }
    
    // ============================================================
    // WebGL Setup
    // ============================================================
    function initWebGL() {
      gl = glCanvas.getContext('webgl', { alpha: false });
      if (!gl) {
        console.error('WebGL not supported');
        return false;
      }
      
      // Create shaders
      const vertShader = createShader(gl, 'vert-shader', gl.VERTEX_SHADER);
      const fragShader = createShader(gl, 'frag-shader', gl.FRAGMENT_SHADER);
      
      // Create program
      program = gl.createProgram();
      gl.attachShader(program, vertShader);
      gl.attachShader(program, fragShader);
      gl.linkProgram(program);
      gl.useProgram(program);
      
      // Create rectangle (full screen quad)
      const posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1,  -1, 1,
        -1,  1,  1, -1,   1, 1
      ]), gl.STATIC_DRAW);
      
      const posLocation = gl.getAttribLocation(program, 'a_position');
      gl.enableVertexAttribArray(posLocation);
      gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
      
      // Texture coordinates
      const texBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,  1, 0,  0, 1,
        0, 1,  1, 0,  1, 1
      ]), gl.STATIC_DRAW);
      
      const texLocation = gl.getAttribLocation(program, 'a_texCoord');
      gl.enableVertexAttribArray(texLocation);
      gl.vertexAttribPointer(texLocation, 2, gl.FLOAT, false, 0, 0);
      
      // Create textures
      waterMapTexture = createTexture(0);
      fgTexture = createTexture(1);
      bgTexture = createTexture(2);
      
      // Set uniforms
      gl.uniform1i(gl.getUniformLocation(program, 'u_waterMap'), 0);
      gl.uniform1i(gl.getUniformLocation(program, 'u_textureFg'), 1);
      gl.uniform1i(gl.getUniformLocation(program, 'u_textureBg'), 2);
      gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), width, height);
      gl.uniform1f(gl.getUniformLocation(program, 'u_minRefraction'), 256);
      gl.uniform1f(gl.getUniformLocation(program, 'u_refractionDelta'), 256);
      gl.uniform1f(gl.getUniformLocation(program, 'u_brightness'), 1.1);
      gl.uniform1f(gl.getUniformLocation(program, 'u_alphaMultiply'), 6);
      gl.uniform1f(gl.getUniformLocation(program, 'u_alphaSubtract'), 3);
      
      return true;
    }
    
    function createShader(gl, id, type) {
      const shader = gl.createShader(type);
      const source = document.getElementById(id).text;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
      }
      return shader;
    }
    
    function createTexture(unit) {
      const texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0 + unit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      return texture;
    }
    
    function updateTexture(texture, unit, source) {
      gl.activeTexture(gl.TEXTURE0 + unit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
    }
    
    // ============================================================
    // Background textures (from camera)
    // ============================================================
    let textureFg, textureFgCtx;
    let textureBg, textureBgCtx;
    const textureBgSize = { width: 384, height: 256 };
    const textureFgSize = { width: 192, height: 128 };
    
    function createBackgroundTextures() {
      textureFg = document.createElement('canvas');
      textureFg.width = textureFgSize.width;
      textureFg.height = textureFgSize.height;
      textureFgCtx = textureFg.getContext('2d');
      
      textureBg = document.createElement('canvas');
      textureBg.width = textureBgSize.width;
      textureBg.height = textureBgSize.height;
      textureBgCtx = textureBg.getContext('2d');
    }
    
    function generateTextures() {
      // Draw camera to foreground (clear, for refraction)
      textureFgCtx.save();
      textureFgCtx.scale(-1, 1);
      textureFgCtx.drawImage(video, -textureFgSize.width, 0, textureFgSize.width, textureFgSize.height);
      textureFgCtx.restore();
      
      // Draw camera to background (blurred via small size)
      textureBgCtx.save();
      textureBgCtx.scale(-1, 1);
      textureBgCtx.drawImage(video, -textureBgSize.width, 0, textureBgSize.width, textureBgSize.height);
      textureBgCtx.restore();
      
      // Apply slight darkening to background
      textureBgCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      textureBgCtx.fillRect(0, 0, textureBgSize.width, textureBgSize.height);
    }
    
    // ============================================================
    // Main Loop
    // ============================================================
    function render() {
      // Update raindrops
      raindrops.update();
      
      // Generate camera textures
      generateTextures();
      
      // Update WebGL textures
      updateTexture(waterMapTexture, 0, raindrops.canvas);
      updateTexture(fgTexture, 1, textureFg);
      updateTexture(bgTexture, 2, textureBg);
      
      // Draw
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      
      requestAnimationFrame(render);
    }
    
    // ============================================================
    // Load Codrops drop images from embedded Base64
    // ============================================================
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load image`));
        img.src = src;
      });
    }
    
    async function loadDropImages() {
      const [dropColor, dropAlpha] = await Promise.all([
        loadImage(DROP_COLOR_BASE64),
        loadImage(DROP_ALPHA_BASE64)
      ]);
      return { dropColor, dropAlpha };
    }
    
    // ============================================================
    // Initialize
    // ============================================================
    async function init() {
      try {
        // Load Codrops drop images from embedded Base64
        loading.querySelector('p').textContent = '画像を読み込み中...';
        const { dropColor, dropAlpha } = await loadDropImages();
        dropColorImg = dropColor;
        dropAlphaImg = dropAlpha;
        
        // Get camera
        loading.querySelector('p').textContent = 'カメラを初期化中...';
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
        });
        video.srcObject = stream;
        await video.play();
        
        // Setup canvas
        resize();
        window.addEventListener('resize', resize);
        
        // Init WebGL
        if (!initWebGL()) {
          throw new Error('WebGL init failed');
        }
        
        // Create background textures
        createBackgroundTextures();
        
        // Create raindrops with Codrops images
        raindrops = new Raindrops(width, height, dpi, dropAlphaImg, dropColorImg, {
          minR: 20,
          maxR: 50,
          rainChance: 0.35,
          rainLimit: 6,
          dropletsRate: 50,
          dropletsSize: [3, 5.5],
          trailRate: 1,
          trailScaleRange: [0.25, 0.35],
          collisionRadiusIncrease: 0.0002
        });
        
        loading.style.display = 'none';
        
        // Start
        requestAnimationFrame(render);
        
      } catch (err) {
        console.error(err);
        loading.innerHTML = `
          <p style="color: #ff6b6b;">エラー: ${err.message}</p>
        `;
      }
    }
    
    function resize() {
      width = window.innerWidth * dpi;
      height = window.innerHeight * dpi;
      glCanvas.width = width;
      glCanvas.height = height;
      glCanvas.style.width = window.innerWidth + 'px';
      glCanvas.style.height = window.innerHeight + 'px';
      
      if (gl) {
        gl.viewport(0, 0, width, height);
        gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), width, height);
      }
      
      if (raindrops) {
        raindrops.width = width;
        raindrops.height = height;
        raindrops.canvas.width = width;
        raindrops.canvas.height = height;
        raindrops.droplets.width = width * raindrops.dropletsPixelDensity;
        raindrops.droplets.height = height * raindrops.dropletsPixelDensity;
      }
    }
    
    // ============================================================
    // UI Controls
    // ============================================================
    document.getElementById('toggleRain').addEventListener('click', function() {
      isRaining = !isRaining;
      raindrops.options.raining = isRaining;
      this.textContent = isRaining ? '? 停止' : '? 再開';
      this.classList.toggle('active', !isRaining);
    });
    
    document.getElementById('clearBtn').addEventListener('click', function() {
      raindrops.clearDrops();
    });
    
    document.getElementById('rainAmount').addEventListener('input', function() {
      rainIntensity = this.value / 100;
      raindrops.options.rainChance = 0.35 * rainIntensity;
      raindrops.options.dropletsRate = 50 * rainIntensity;
    });
    
    // Start
    init();
  </script>
</body>
</html>
