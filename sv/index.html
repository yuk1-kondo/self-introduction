<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Sound Visualizer</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    .back-home {
      position: fixed;
      top: 18px;
      left: 18px;
      z-index: 12000;
    }

    .back-home a {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 9px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(0, 0, 0, 0.45);
      color: #fff;
      text-decoration: none;
      font-size: 12px;
      letter-spacing: 0.08em;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }

    .back-home a:hover {
      background: rgba(0, 0, 0, 0.65);
      border-color: rgba(255, 255, 255, 0.4);
    }

    @media (max-width: 768px) {
      .back-home { top: 14px; left: 14px; }
      .back-home a { padding: 8px 12px; font-size: 11px; letter-spacing: 0.05em; }
    }
    
    :root {
      --bg: #0a0a0a;
      --surface: #111;
      --border: #222;
      --text: #fff;
      --text-muted: #666;
      --accent1: #ff006e;
      --accent2: #8338ec;
      --accent3: #3a86ff;
      --accent4: #06ffa5;
    }
    
    html, body { 
      background: var(--bg);
      color: var(--text); 
      font-family: 'Space Grotesk', system-ui, sans-serif;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }
    
    .app { 
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 32px;
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      z-index: 10;
    }
    
    .logo {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 1px;
      background: linear-gradient(90deg, var(--accent1), var(--accent2), var(--accent3));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .hint {
      font-size: 12px;
      color: var(--text-muted);
    }
    
    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 32px;
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      flex-wrap: wrap;
      z-index: 10;
    }
    
    .btn {
      font-family: inherit;
      font-size: 13px;
      font-weight: 500;
      padding: 10px 20px;
      border: 1px solid var(--border);
      border-radius: 100px;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--text-muted);
    }
    
    .btn.active {
      background: linear-gradient(135deg, var(--accent1), var(--accent2));
      border-color: transparent;
      color: white;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent1), var(--accent2));
      border-color: transparent;
    }
    
    .btn-primary:hover {
      opacity: 0.9;
      transform: scale(1.02);
    }
    
    .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 4px;
    }
    
    .slider {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .slider-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      width: 80px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: linear-gradient(135deg, var(--accent1), var(--accent3));
      border-radius: 50%;
      cursor: pointer;
    }
    
    .stage { 
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    
    #visualizerCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Volume meter */
    .volume-meter {
      position: fixed;
      left: 24px;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 200px;
      background: var(--surface);
      border-radius: 4px;
      border: 1px solid var(--border);
      overflow: hidden;
      z-index: 20;
    }
    
    .volume-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(to top, var(--accent4), var(--accent3), var(--accent1));
      border-radius: 4px;
      transition: height 0.05s ease;
    }
    
    /* BPM display */
    .bpm-display {
      position: fixed;
      right: 24px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--surface);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
      z-index: 20;
    }
    
    .bpm-value {
      font-size: 32px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent1), var(--accent3));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .bpm-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }
    
    /* Start overlay */
    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      gap: 24px;
    }
    
    .start-overlay.hidden {
      display: none;
    }
    
    .start-title {
      font-size: 32px;
      font-weight: 700;
      background: linear-gradient(90deg, var(--accent1), var(--accent2), var(--accent3));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .start-subtitle {
      color: var(--text-muted);
      font-size: 14px;
    }
    
    .start-btn {
      font-family: inherit;
      font-size: 16px;
      font-weight: 600;
      padding: 16px 48px;
      border: none;
      border-radius: 100px;
      background: linear-gradient(135deg, var(--accent1), var(--accent2));
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .start-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 40px rgba(255, 0, 110, 0.3);
    }
    
    /* Color theme selector */
    .theme-selector {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    
    .theme-btn {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s ease;
    }
    
    .theme-btn:hover { transform: scale(1.2); }
    .theme-btn.active { border-color: white; }
    
    .theme-neon { background: linear-gradient(135deg, #ff006e, #8338ec); }
    .theme-ocean { background: linear-gradient(135deg, #0077b6, #00b4d8); }
    .theme-fire { background: linear-gradient(135deg, #ff4500, #ffd700); }
    .theme-forest { background: linear-gradient(135deg, #2d6a4f, #40916c); }
    .theme-mono { background: linear-gradient(135deg, #fff, #666); }
    
    /* Mobile responsive */
    @media (max-width: 640px) {
      header { 
        padding: 16px 20px; 
        flex-direction: column;
        gap: 8px;
      }
      .controls { 
        padding: 12px 20px; 
        gap: 8px; 
        justify-content: center;
      }
      .btn { padding: 8px 14px; font-size: 12px; }
      .divider { display: none; }
      .volume-meter {
        left: 12px;
        height: 150px;
      }
      .bpm-display {
        right: 12px;
        padding: 12px;
      }
      .bpm-value { font-size: 24px; }
      .start-title { font-size: 24px; }
    }
  </style>
</head>
<body>
  <div class="back-home"><a href="/">‚Üê TOP</a></div>
  <div class="start-overlay" id="startOverlay">
    <h1 class="start-title">SOUND VISUALIZER</h1>
    <p class="start-subtitle">Click to enable microphone and start the visual experience</p>
    <button class="start-btn" id="startBtn">üé§ START</button>
  </div>
  
  <div class="app">
    <header>
      <div class="logo">SOUND VISUALIZER</div>
      <div class="hint">üé§ Make some noise!</div>
    </header>
    
    <div class="controls">
      <button class="btn" id="modeWave">Wave</button>
      <button class="btn active" id="modeCircle">Circle</button>
      <button class="btn" id="modeBars">Bars</button>
      <button class="btn" id="modeParticles">Particles</button>
      <button class="btn" id="modeSpiral">Spiral</button>
      <button class="btn" id="modeTerrain">Terrain</button>
      
      <div class="divider"></div>
      
      <div class="theme-selector">
        <span class="slider-label">Theme</span>
        <div class="theme-btn theme-neon active" data-theme="neon"></div>
        <div class="theme-btn theme-ocean" data-theme="ocean"></div>
        <div class="theme-btn theme-fire" data-theme="fire"></div>
        <div class="theme-btn theme-forest" data-theme="forest"></div>
        <div class="theme-btn theme-mono" data-theme="mono"></div>
      </div>
      
      <div class="divider"></div>
      
      <div class="slider">
        <span class="slider-label">Sensitivity</span>
        <input type="range" id="sensitivity" min="0.5" max="3" step="0.1" value="1.5">
      </div>
      
      <button class="btn" id="toggleMirror">Mirror: OFF</button>
    </div>
    
    <div class="stage">
      <canvas id="visualizerCanvas"></canvas>
    </div>
    
    <div class="volume-meter">
      <div class="volume-fill" id="volumeFill"></div>
    </div>
    
    <div class="bpm-display">
      <div class="bpm-value" id="bpmValue">--</div>
      <div class="bpm-label">BPM</div>
    </div>
  </div>

  <script>
    // ============================================================
    // Sound Visualizer - Enhanced & Optimized
    // ============================================================
    
    const canvas = document.getElementById('visualizerCanvas');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('startOverlay');
    const volumeFill = document.getElementById('volumeFill');
    const bpmValueEl = document.getElementById('bpmValue');
    
    let audioContext;
    let analyser;
    let dataArray;
    let bufferLength;
    let isRunning = false;
    
    // Settings
    let visualMode = 'circle';
    let sensitivity = 1.5;
    let mirrorMode = false;
    let colorTheme = 'neon';
    
    // Color themes
    const THEMES = {
      neon: ['#ff006e', '#8338ec', '#3a86ff', '#06ffa5', '#ffbe0b'],
      ocean: ['#03045e', '#0077b6', '#00b4d8', '#90e0ef', '#caf0f8'],
      fire: ['#ff4500', '#ff6b35', '#f7931e', '#ffd700', '#fff8dc'],
      forest: ['#1b4332', '#2d6a4f', '#40916c', '#52b788', '#95d5b2'],
      mono: ['#ffffff', '#cccccc', '#999999', '#666666', '#333333']
    };
    
    let colors = THEMES.neon;
    
    // Optimized particle system with object pooling
    const PARTICLE_POOL_SIZE = 150;
    let particlePool = [];
    let activeParticles = [];
    let particleIndex = 0;
    
    class Particle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.size = 0;
        this.color = colors[0];
        this.life = 0;
        this.maxLife = 1;
        this.active = false;
      }
      
      init(x, y, size, color, vx, vy, life) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.active = true;
      }
      
      update() {
        if (!this.active) return false;
        
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.016;
        this.vx *= 0.98;
        this.vy *= 0.98;
        
        if (this.life <= 0) {
          this.active = false;
          return false;
        }
        return true;
      }
      
      draw() {
        if (!this.active) return;
        
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Initialize particle pool
    function initParticlePool() {
      particlePool = [];
      activeParticles = [];
      for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
        particlePool.push(new Particle());
      }
    }
    
    // Get a particle from pool
    function getParticle() {
      // Find inactive particle
      for (let i = 0; i < particlePool.length; i++) {
        if (!particlePool[i].active) {
          return particlePool[i];
        }
      }
      // Pool exhausted, return null
      return null;
    }
    
    // BPM detection
    let beatHistory = [];
    let lastBeatTime = 0;
    let estimatedBPM = 0;
    
    function detectBeat(volume) {
      const now = Date.now();
      const threshold = 0.4;
      
      if (volume > threshold && now - lastBeatTime > 200) {
        if (lastBeatTime > 0) {
          const interval = now - lastBeatTime;
          beatHistory.push(interval);
          
          if (beatHistory.length > 8) {
            beatHistory.shift();
          }
          
          if (beatHistory.length >= 4) {
            const avgInterval = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            estimatedBPM = Math.round(60000 / avgInterval);
            estimatedBPM = Math.max(60, Math.min(200, estimatedBPM));
            bpmValueEl.textContent = estimatedBPM;
          }
        }
        lastBeatTime = now;
        return true;
      }
      return false;
    }
    
    // Spiral state
    let spiralAngle = 0;
    
    // Terrain state
    let terrainHistory = [];
    const TERRAIN_HISTORY_SIZE = 100;
    
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    
    async function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.8;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        
        initParticlePool();
        
        isRunning = true;
        startOverlay.classList.add('hidden');
        
        animate();
        
      } catch (err) {
        console.error('Audio error:', err);
        alert('Could not access microphone. Please allow microphone access.');
      }
    }
    
    function getAverageVolume() {
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i];
      }
      return (sum / bufferLength) / 255;
    }
    
    function getFrequencyBands() {
      const bass = dataArray.slice(0, Math.floor(bufferLength * 0.1));
      const mid = dataArray.slice(Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5));
      const high = dataArray.slice(Math.floor(bufferLength * 0.5));
      
      const avgBass = bass.reduce((a, b) => a + b, 0) / bass.length / 255;
      const avgMid = mid.reduce((a, b) => a + b, 0) / mid.length / 255;
      const avgHigh = high.reduce((a, b) => a + b, 0) / high.length / 255;
      
      return { bass: avgBass, mid: avgMid, high: avgHigh };
    }
    
    function drawWave() {
      const width = canvas.width;
      const height = canvas.height;
      const centerY = height / 2;
      
      ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      for (let layer = 0; layer < 3; layer++) {
        ctx.beginPath();
        
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, colors[layer]);
        gradient.addColorStop(0.5, colors[layer + 1]);
        gradient.addColorStop(1, colors[(layer + 2) % colors.length]);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3 - layer;
        ctx.globalAlpha = 1 - layer * 0.3;
        
        const sliceWidth = width / bufferLength;
        let x = 0;
        
        for (let i = 0; i < bufferLength; i++) {
          const v = dataArray[i] / 128.0 * sensitivity;
          const y = centerY + (v - 1) * (height / 4) * (1 + layer * 0.3);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          
          x += sliceWidth;
        }
        
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
    }
    
    function drawCircle() {
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const baseRadius = Math.min(width, height) * 0.2;
      
      ctx.fillStyle = 'rgba(10, 10, 10, 0.15)';
      ctx.fillRect(0, 0, width, height);
      
      const avgVolume = getAverageVolume();
      
      for (let ring = 0; ring < 3; ring++) {
        const ringRadius = baseRadius + ring * 40;
        
        ctx.beginPath();
        
        for (let i = 0; i < bufferLength; i++) {
          const angle = (i / bufferLength) * Math.PI * 2 - Math.PI / 2;
          const amplitude = dataArray[i] / 255 * sensitivity;
          const radius = ringRadius + amplitude * 100 * (1 - ring * 0.2);
          
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, ringRadius + 150);
        gradient.addColorStop(0, colors[ring % colors.length] + '00');
        gradient.addColorStop(0.5, colors[ring % colors.length] + '80');
        gradient.addColorStop(1, colors[(ring + 1) % colors.length] + '40');
        
        ctx.strokeStyle = colors[ring % colors.length];
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.1 + avgVolume * 0.2;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius);
      glowGradient.addColorStop(0, `${colors[0]}${Math.floor(avgVolume * 128).toString(16).padStart(2, '0')}`);
      glowGradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawBars() {
      const width = canvas.width;
      const height = canvas.height;
      
      ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
      ctx.fillRect(0, 0, width, height);
      
      const barCount = 64;
      const barWidth = width / barCount - 2;
      const step = Math.floor(bufferLength / barCount);
      
      for (let i = 0; i < barCount; i++) {
        const dataIndex = i * step;
        const value = dataArray[dataIndex] / 255 * sensitivity;
        const barHeight = value * height * 0.7;
        
        const x = i * (barWidth + 2);
        const y = height - barHeight;
        
        const colorIndex = Math.floor((i / barCount) * colors.length);
        const gradient = ctx.createLinearGradient(x, y, x, height);
        gradient.addColorStop(0, colors[colorIndex % colors.length]);
        gradient.addColorStop(1, colors[(colorIndex + 1) % colors.length]);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth, barHeight);
        
        // Mirror effect
        if (mirrorMode) {
          ctx.globalAlpha = 0.3;
          ctx.fillRect(x, height, barWidth, -barHeight * 0.3);
          ctx.globalAlpha = 1;
        }
      }
    }
    
    function drawParticles() {
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Fade background
      ctx.fillStyle = 'rgba(10, 10, 10, 0.08)';
      ctx.fillRect(0, 0, width, height);
      
      const avgVolume = getAverageVolume();
      const bands = getFrequencyBands();
      const isBeat = detectBeat(bands.bass);
      
      // Spawn particles based on volume (limited rate)
      if (avgVolume > 0.1) {
        const spawnCount = Math.min(3, Math.floor(avgVolume * 5 * sensitivity));
        
        for (let i = 0; i < spawnCount; i++) {
          const particle = getParticle();
          if (particle) {
            const angle = Math.random() * Math.PI * 2;
            const speed = avgVolume * 8 + Math.random() * 4;
            const colorIndex = Math.floor(Math.random() * colors.length);
            
            particle.init(
              centerX,
              centerY,
              4 + avgVolume * 12,
              colors[colorIndex],
              Math.cos(angle) * speed,
              Math.sin(angle) * speed,
              1 + Math.random() * 0.5
            );
          }
        }
      }
      
      // Update and draw particles
      ctx.globalAlpha = 1;
      for (const particle of particlePool) {
        if (particle.active) {
          particle.update();
          particle.draw();
        }
      }
      ctx.globalAlpha = 1;
      
      // Center pulse on beat
      if (isBeat) {
        const pulseRadius = 80 + avgVolume * 60;
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, pulseRadius);
        gradient.addColorStop(0, colors[0] + '80');
        gradient.addColorStop(0.5, colors[1] + '40');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawSpiral() {
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      
      ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      const avgVolume = getAverageVolume();
      spiralAngle += 0.02 + avgVolume * 0.05;
      
      const arms = 5;
      const pointsPerArm = 100;
      
      for (let arm = 0; arm < arms; arm++) {
        ctx.beginPath();
        
        const armOffset = (arm / arms) * Math.PI * 2;
        
        for (let i = 0; i < pointsPerArm; i++) {
          const t = i / pointsPerArm;
          const dataIndex = Math.floor(t * bufferLength);
          const amplitude = dataArray[dataIndex] / 255 * sensitivity;
          
          const radius = 50 + t * 200 + amplitude * 100;
          const angle = spiralAngle + armOffset + t * Math.PI * 4;
          
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        const gradient = ctx.createLinearGradient(
          centerX - 300, centerY - 300,
          centerX + 300, centerY + 300
        );
        gradient.addColorStop(0, colors[arm % colors.length]);
        gradient.addColorStop(1, colors[(arm + 1) % colors.length]);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2 + avgVolume * 3;
        ctx.stroke();
      }
      
      // Center glow
      const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
      glowGradient.addColorStop(0, colors[0] + Math.floor(avgVolume * 200).toString(16).padStart(2, '0'));
      glowGradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, 100, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawTerrain() {
      const width = canvas.width;
      const height = canvas.height;
      
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, width, height);
      
      // Add current frame to history
      const currentFrame = [];
      for (let i = 0; i < bufferLength; i++) {
        currentFrame.push(dataArray[i] / 255 * sensitivity);
      }
      terrainHistory.unshift(currentFrame);
      
      if (terrainHistory.length > TERRAIN_HISTORY_SIZE) {
        terrainHistory.pop();
      }
      
      // Draw terrain from history
      const rows = terrainHistory.length;
      const cols = bufferLength;
      const rowHeight = height / (TERRAIN_HISTORY_SIZE * 0.7);
      const colWidth = width / cols;
      
      for (let row = rows - 1; row >= 0; row--) {
        const frame = terrainHistory[row];
        const y = height * 0.8 - row * rowHeight;
        const alpha = 1 - (row / TERRAIN_HISTORY_SIZE) * 0.8;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        
        for (let col = 0; col < cols; col++) {
          const x = col * colWidth;
          const amplitude = frame[col] * 150;
          ctx.lineTo(x, y - amplitude);
        }
        
        ctx.lineTo(width, y);
        
        const colorIndex = Math.floor((row / TERRAIN_HISTORY_SIZE) * colors.length);
        const gradient = ctx.createLinearGradient(0, y - 150, 0, y);
        gradient.addColorStop(0, colors[colorIndex % colors.length] + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
        gradient.addColorStop(1, colors[(colorIndex + 1) % colors.length] + '00');
        
        ctx.fillStyle = gradient;
        ctx.globalAlpha = alpha;
        ctx.fill();
        
        ctx.strokeStyle = colors[colorIndex % colors.length];
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
    }
    
    function animate() {
      if (!isRunning) return;
      
      analyser.getByteFrequencyData(dataArray);
      
      const avgVolume = getAverageVolume();
      volumeFill.style.height = (avgVolume * 100 * sensitivity) + '%';
      
      switch (visualMode) {
        case 'wave':
          drawWave();
          break;
        case 'circle':
          drawCircle();
          break;
        case 'bars':
          drawBars();
          break;
        case 'particles':
          drawParticles();
          break;
        case 'spiral':
          drawSpiral();
          break;
        case 'terrain':
          drawTerrain();
          break;
      }
      
      requestAnimationFrame(animate);
    }
    
    // UI Controls
    document.getElementById('startBtn').addEventListener('click', initAudio);
    
    const modeButtons = ['Wave', 'Circle', 'Bars', 'Particles', 'Spiral', 'Terrain'];
    modeButtons.forEach(mode => {
      document.getElementById('mode' + mode).addEventListener('click', function() {
        visualMode = mode.toLowerCase();
        updateModeButtons();
        
        // Clear canvas on mode switch
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Reset mode-specific state
        if (visualMode === 'terrain') {
          terrainHistory = [];
        }
        if (visualMode === 'particles') {
          initParticlePool();
        }
      });
    });
    
    function updateModeButtons() {
      document.querySelectorAll('.controls .btn').forEach(btn => {
        if (btn.id.startsWith('mode')) {
          btn.classList.remove('active');
        }
      });
      const activeBtn = document.getElementById('mode' + visualMode.charAt(0).toUpperCase() + visualMode.slice(1));
      if (activeBtn) activeBtn.classList.add('active');
    }
    
    // Theme selector
    document.querySelectorAll('.theme-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        colorTheme = this.dataset.theme;
        colors = THEMES[colorTheme];
      });
    });
    
    document.getElementById('sensitivity').addEventListener('input', function() {
      sensitivity = parseFloat(this.value);
    });
    
    document.getElementById('toggleMirror').addEventListener('click', function() {
      mirrorMode = !mirrorMode;
      this.textContent = 'Mirror: ' + (mirrorMode ? 'ON' : 'OFF');
      this.classList.toggle('active', mirrorMode);
    });
    
    // Initialize
    resize();
    window.addEventListener('resize', resize);
    
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  </script>
</body>
</html>
