# プロジェクト解説ドキュメント

## 目次

1. [プロジェクト概要](#プロジェクト概要)
2. [アーキテクチャ](#アーキテクチャ)
3. [各ページの機能詳細](#各ページの機能詳細)
4. [コードロジック解説](#コードロジック解説)
5. [技術スタック](#技術スタック)
6. [主要クラス・関数リファレンス](#主要クラス関数リファレンス)

---

## プロジェクト概要

このプロジェクトは、YUKI KONDO氏の自己紹介ポートフォリオサイトです。インタラクティブなCanvasベースのパーティクルシステムと、MediaPipeを活用した手のトラッキング機能を組み合わせた、モダンで革新的なWebアプリケーションです。

### 主な特徴

- **インタラクティブなパーティクルシステム**: マウス、タッチ、手のジェスチャーで操作可能
- **MediaPipe統合**: 手のトラッキングによる直感的な操作
- **多言語対応**: 英語/日本語の切り替え機能
- **レスポンシブデザイン**: デスクトップ・モバイル両対応
- **WebGL活用**: 高度な視覚効果（一部ページ）

---

## アーキテクチャ

### ディレクトリ構造

プロジェクトは以下のディレクトリ構造で構成されています：

- **ルートディレクトリ**
  - `index.html` - メインページ（ホーム）
  - `home.css`, `home.js` - ホームページ用スタイル・スクリプト
  - `style.css` - 共通スタイル
  - `script.js` - 共通スクリプト（ポートフォリオページ用）
  - `portfolio_data.js` - ポートフォリオデータ

- **サブディレクトリ**
  - `xx/` - ポートフォリオページ
  - `oo/` - ソーシャルページ
  - `wd/` - Water Drops（雨滴エフェクト）
  - `fg/` - Foggy Window（曇りガラスエフェクト）
  - `dm/` - Distortion Mirror（歪みミラー）
  - `oc/` - Optical Camouflage（光学迷彩）

### データフロー

システムのデータフローは以下の順序で処理されます：

1. **ユーザー入力** → マウス、タッチ、カメラ入力
2. **イベントハンドラ** → マウス/タッチ/MediaPipeイベントを処理
3. **状態管理** → particles、projectNodesなどの状態を更新
4. **アニメーションループ** → requestAnimationFrameで60fps描画
5. **Canvas描画** → 2DまたはWebGLコンテキストで描画
6. **画面更新** → ブラウザに表示

---

## 各ページの機能詳細

### 1. メインページ (index.html)

**機能概要**: MediaPipeを使った手のトラッキングでパーティクルを操作するインタラクティブなホームページ

**主要機能**:
- **パーティクルシステム**: 80個（デスクトップ）/ 40個（モバイル）のパーティクルが動的に接続
- **手のトラッキング**: 人差し指でパーティクルを操作、ピンチで集約・解放で爆発
- **カスタムカーソル**: 手の動きに追従する視覚的フィードバック
- **カメラ制御**: ボタンでカメラの有効/無効を切り替え

**技術的詳細**:
- MediaPipe Hands APIを使用
- 人差し指の先端（landmark 8）を追跡
- 親指と人差し指の距離でピンチ検出
- スムージング処理で自然な動きを実現

### 2. ポートフォリオページ (xx/index.html)

**機能概要**: プロジェクトノードをクリック/タップして詳細を表示するインタラクティブなポートフォリオ

**主要機能**:
- **プロジェクトノード**: ダイヤモンド形状のノードが画面上を移動
- **パーティクル接続**: ノード間、マウスとの接続線を描画
- **モーダル表示**: ノードクリックでプロジェクト詳細を表示
- **多言語対応**: EN/JA切り替えボタン
- **ロードアニメーション**: ノードが順番にフェードイン・スケールアニメーション

**技術的詳細**:
- `Particle`クラス: 背景パーティクル
- `ProjectNode`クラス: プロジェクトノード（ダイヤモンド形状）
- 距離ベースの接続線描画
- ショックウェーブ効果（ダブルクリック/ダブルタップ）

### 3. ソーシャルページ (oo/index.html)

**機能概要**: ソーシャルメディアリンクを表示するダークテーマのページ

**主要機能**:
- **ダークテーマ**: 白/グレーのパーティクルカラー
- **ソーシャルノード**: X、Qiita、noteなどのリンク
- **同様のインタラクティブシステム**: ポートフォリオページと同じパーティクルシステム

**技術的詳細**:
- `THEME_COLORS`でカラーパレットを定義
- `social_data.js`でソーシャルデータを管理

### 4. Water Drops (wd/index.html)

**機能概要**: WebGLを使ったリアルな雨滴エフェクト。手の動きで雨滴を操作可能

**主要機能**:
- **リアルな雨滴**: Codropsの技術をベースにした物理ベースの雨滴
- **WebGLシェーダー**: 屈折、色収差、フレネル効果、スペキュラハイライト
- **手のトラッキング**: 手の動きで雨滴を散らす、グーで反重力モード
- **カメラ背景**: リアルタイムカメラ映像を背景に使用

**技術的詳細**:
- WebGL Fragment Shaderで高度な視覚効果
- `Raindrops`クラス: 雨滴の物理シミュレーション
- 衝突検出、重力、反重力モード
- MediaPipe Handsで手の位置・速度を検出

### 5. Foggy Window (fg/index.html)

**機能概要**: 曇りガラスエフェクト。人差し指で曇りを拭き取る

**主要機能**:
- **曇りガラス**: カメラ映像に白い曇りをオーバーレイ
- **指で描画**: 人差し指を立てて曇りを拭き取る
- **自動フェード**: 拭き取った部分が徐々に曇り戻る
- **ブラシサイズ調整**: UIでブラシサイズを変更可能

**技術的詳細**:
- 3つのCanvasレイヤー（ビデオ、曇り、描画）
- `fogMask`: Float32Arrayで曇りの状態を管理
- MediaPipe Handsで人差し指のみを検出
- ソフトブラシエフェクト（中心がより透明）

### 6. Distortion Mirror (dm/index.html)

**機能概要**: WebGLシェーダーでリアルタイム歪みエフェクト。グーで歪みを活性化

**主要機能**:
- **3つの歪みモード**: Swirl（渦巻き）、Bulge（膨らみ）、Wave（波）
- **グーで活性化**: グーを握ると歪みが徐々に強くなる
- **歪みメーター**: リアルタイムで歪みの強さを表示
- **カメラ背景**: リアルタイムカメラ映像を歪ませる

**技術的詳細**:
- WebGL Fragment Shaderで歪み計算
- MediaPipe Handsでグー検出
- スムーズな歪み遷移（線形補間）
- ビネット効果と色調補正

### 7. Optical Camouflage (oc/index.html)

**機能概要**: MediaPipe Selfie Segmentationを使った光学迷彩エフェクト

**主要機能**:
- **人物セグメンテーション**: MediaPipeで人物を検出
- **背景置換**: 過去フレームまたはフリーズした背景で人物を隠す
- **自動フリーズ**: 人物が画面外に出たときに背景を自動キャプチャ
- **ジェスチャー制御**: グーで迷彩のON/OFFを切り替え

**技術的詳細**:
- WebGL2 Fragment Shaderでマルチレイヤー合成
- リングバッファで過去24フレームを保持
- マスクのブラー・拡張処理でエッジを滑らかに
- 波状歪みエフェクトで視覚的深度を追加

---

## コードロジック解説

### パーティクルシステムの基本構造

#### 1. 初期化フロー

システムの初期化は以下の4つのステップで行われます：

**ステップ1: デバイス検出**
- `detectMobile()`関数を呼び出し
- モバイル/デスクトップの判定
- パーティクル数などのパラメータを決定

**ステップ2: Canvasサイズ設定**
- `resize()`関数でウィンドウサイズを取得
- Canvasの幅と高さを設定
- 画面サイズに合わせて調整

**ステップ3: パーティクル生成**
- ループでパーティクルを生成
- 各パーティクルにランダムな位置・速度を設定
- 色と形状をランダムに決定

**ステップ4: アニメーションループ開始**
- `animate()`関数を呼び出し
- 60fpsで連続描画を開始

#### 2. アニメーションループ

メインのアニメーションループは以下の処理を毎フレーム実行します：

**ステップ1: Canvasクリア**
- 前フレームの描画内容を消去
- `ctx.clearRect()`で画面全体をクリア

**ステップ2: 接続線描画**
- パーティクル間の距離を計算
- 一定距離以内のパーティクルを線で接続
- 距離に応じて透明度を調整

**ステップ3: パーティクル更新・描画**
- 各パーティクルの`update()`メソッドで位置を更新
- `draw()`メソッドでCanvasに描画
- 物理演算とマウス/手の影響を適用

**ステップ4: 次のフレームをリクエスト**
- `requestAnimationFrame()`で次のフレームを予約
- ブラウザの最適なタイミングで再描画

#### 3. パーティクルの物理演算

**基本移動**

パーティクルは現在の速度ベクトル（vx, vy）を位置（x, y）に加算することで移動します。これにより、等速直線運動を実現しています。

**境界反射**

パーティクルが画面端に到達すると、速度ベクトルを反転させます：
- X軸の境界: 左端（x < 0）または右端（x > width）で速度vxを反転
- Y軸の境界: 上端（y < 0）または下端（y > height）で速度vyを反転

**マウス/手の影響**

パーティクルとマウス/手の位置関係を計算し、一定距離内にある場合は引き寄せる力を加えます：

1. **距離計算**: パーティクルとマウスの位置の差分（dx, dy）を計算
2. **ユークリッド距離**: `Math.sqrt(dx * dx + dy * dy)`で距離を取得
3. **力の計算**: 距離が近いほど強い力を適用（逆比例）
4. **角度の計算**: `Math.atan2(dy, dx)`で力の方向を決定
5. **速度への加算**: 三角関数で力のベクトルを速度に加算

### MediaPipe統合

#### 手のトラッキング設定

MediaPipe Handsの初期化は以下の手順で行います：

**インスタンス作成**
- Handsオブジェクトを生成
- CDNからモデルファイルをロードするためのパスを設定

**検出オプション**
- `maxNumHands`: 検出する手の最大数（通常は1）
- `modelComplexity`: モデルの複雑度（0=軽量、1=標準、2=高精度）
- `minDetectionConfidence`: 検出の最小信頼度（0.0-1.0）
- `minTrackingConfidence`: トラッキングの最小信頼度（0.0-1.0）

**コールバック関数**
- 手が検出された際に呼ばれる関数を設定
- `results.multiHandLandmarks`から手のランドマーク（21点）を取得
- 各ランドマークにはx, y, z座標が含まれる

#### ジェスチャー検出

**グー検出**

すべての指が閉じているかを判定します：

1. **ランドマーク取得**: 各指の先端（tip）と付け根（base）のランドマークを取得
2. **Y座標比較**: 指先のY座標が付け根より大きい場合、その指は閉じている
3. **全指判定**: すべての指（人差し指、中指、薬指、小指）が閉じていればグー

**ピンチ検出**

親指と人差し指の距離を計算します：

1. **ランドマーク取得**: 親指の先端（landmark 4）と人差し指の先端（landmark 8）
2. **距離計算**: 2点間のユークリッド距離を計算
3. **閾値判定**: 距離が一定値（PINCH_THRESHOLD）より小さければピンチ状態

### モーダルシステム

#### モーダル表示ロジック

プロジェクト詳細を表示するモーダルは以下の手順で開きます：

**ステップ1: テキストのローカライズ**
- 現在の言語（currentLang）に基づいてテキストを取得
- データ構造が多言語対応（{en: '...', ja: '...'}）の場合に対応

**ステップ2: モーダル要素の更新**
- タイトル、カテゴリ、説明文を設定
- 各要素のinnerTextプロパティを更新

**ステップ3: 画像の表示処理**
- 画像データが存在する場合、srcを設定
- パスの解決とエラーハンドリング
- hiddenクラスを削除して表示

**ステップ4: リンクボタンの調整**
- リンクの種類（mailto、GitHub、外部URL）を判定
- ボタンテキストを適切に変更
- target属性を設定（外部リンクの場合）

**ステップ5: モーダル表示**
- モーダルのhiddenクラスを削除
- CSSトランジションで滑らかに表示

### 多言語対応システム

#### 言語切り替えロジック

言語切り替えは以下の流れで処理されます：

**ステップ1: 言語の更新**
- グローバル変数`currentLang`を新しい言語に設定

**ステップ2: UIテキストの更新**
- `portfolioData.uiTexts`から現在の言語のテキストを取得
- タイトル、サブタイトル、説明文などを更新

**ステップ3: トグルボタンの視覚的更新**
- 言語トグルボタンのクラスを更新
- アクティブな言語を視覚的に強調

**ステップ4: 設定の永続化**
- `localStorage.setItem()`で言語設定を保存
- 次回訪問時に自動的に適用

#### データ構造

多言語対応のデータは以下の構造で管理されます：

- **uiTexts**: UI要素のテキスト（title, subtitle, instructions等）
- **projects**: プロジェクトデータの配列
  - 各プロジェクトは`id`、`title`、`category`、`description`、`link`を持つ
  - テキストフィールドは言語オブジェクト（{en: '...', ja: '...'}）

### WebGLシェーダー（Water Drops）

#### Fragment Shaderの主要処理

**屈折計算**

光の屈折をシミュレートする処理：

1. **屈折ベクトル**: RGB値から屈折方向を計算（-1.0から1.0の範囲に正規化）
2. **屈折強度**: 最小屈折率と深度ベースの追加屈折を合計
3. **色収差**: RGBチャンネルごとに異なる屈折率を適用
   - 赤チャンネル: 0.97倍（弱い屈折）
   - 緑チャンネル: 1.00倍（基準）
   - 青チャンネル: 1.03倍（強い屈折）

**スペキュラハイライト**

水滴表面の光の反射を計算：

1. **位置計算**: Y座標を-1.0から1.0の範囲に正規化
2. **強度計算**: べき乗（pow）関数で上部ほど明るく
3. **深度スケール**: 水滴の深度に応じて明るさを調整

**フレネル効果**

エッジでの反射率の変化を計算：

1. **エッジ距離**: 屈折ベクトルの長さを計算
2. **フレネル係数**: べき乗関数で非線形な反射率を算出
3. **合成**: 屈折色と背景色をフレネル係数で混合

### ショックウェーブ効果

クリック/タップ位置から放射状にパーティクルを散らす処理：

**処理フロー**

1. **距離計算**: 各パーティクルとクリック位置の距離を計算
2. **力の計算**: 距離に反比例する力を算出（近いほど強い）
3. **角度の計算**: `Math.atan2()`で力の方向を決定
4. **速度への加算**: 三角関数で力のベクトルを速度に加算
5. **減衰有効化**: `dampingActive`フラグをtrueに設定

**力の計算式**

力 = SHOCKWAVE_FORCE / (距離 + 10)

分母に10を加えることで、クリック位置で力が無限大になるのを防ぎます。

### ダンピング（減衰）システム

ショックウェーブ後の速度を徐々に減らす処理：

**処理フロー**

1. **速度の大きさを計算**: `Math.sqrt(vx * vx + vy * vy)`
2. **閾値チェック**: 速度が閾値より大きい場合
   - 速度を97%に減らす（毎フレーム3%減速）
   - DAMPING_FACTOR = 0.97
3. **基準速度へ戻す**: 速度が閾値以下になった場合
   - 現在の方向を保持（`Math.atan2()`で角度を取得）
   - 基準速度で速度ベクトルを再設定
   - `dampingActive`フラグをfalseに設定

**目的**

ショックウェーブで加速したパーティクルを徐々に元の速度に戻すことで、自然な動きを実現します。

---

## 技術スタック

### フロントエンド

- **HTML5**: セマンティックマークアップ
- **CSS3**: カスタムプロパティ、アニメーション、レスポンシブデザイン
- **Vanilla JavaScript**: フレームワークなしの純粋なJS
- **Canvas API**: 2Dグラフィックス描画
- **WebGL / WebGL2**: 3Dグラフィックスとシェーダー

### 外部ライブラリ

- **MediaPipe Hands**: 手のトラッキング
- **MediaPipe Selfie Segmentation**: 人物セグメンテーション
- **Google Fonts (Outfit)**: タイポグラフィ

### ブラウザAPI

- **getUserMedia**: カメラアクセス
- **requestAnimationFrame**: アニメーションループ
- **localStorage**: 言語設定の永続化
- **Canvas 2D Context**: 描画処理

---

## 主要クラス・関数リファレンス

### Particle クラス

**役割**: 背景パーティクルの物理演算と描画

**主要メソッド**:
- `constructor()`: 初期位置・速度・色をランダム設定
- `update()`: 位置更新、境界反射、マウス/手の影響を計算
- `draw()`: Canvasにパーティクルを描画

**プロパティ**:
- `x, y`: 位置座標
- `vx, vy`: 速度ベクトル
- `size`: パーティクルのサイズ
- `color`: パーティクルの色
- `dampingActive`: 減衰が有効かどうかのフラグ

### ProjectNode クラス

**役割**: プロジェクトノード（ダイヤモンド形状）の管理

**主要メソッド**:
- `constructor(data, index)`: プロジェクトデータからノードを生成
- `update()`: 位置更新、ホバー検出、ロードアニメーション
- `draw()`: ダイヤモンド形状とラベルを描画
- `checkClick(x, y)`: クリック/タップ検出

**プロパティ**:
- `data`: プロジェクトデータ
- `isHovered`: ホバー状態のフラグ
- `opacity, scale`: ロードアニメーション用の値
- `loadAnimationComplete`: アニメーション完了フラグ

### Raindrops クラス (Water Drops)

**役割**: 雨滴の物理シミュレーション

**主要メソッド**:
- `updateRain()`: 新しい雨滴を生成
- `updateDrops()`: 雨滴の位置・衝突・物理演算
- `updateHandInteraction()`: 手の動きで雨滴に力を加える
- `drawDrop()`: 雨滴を描画（速度ベースの変形）

**プロパティ**:
- `drops`: 雨滴の配列
- `options`: 設定（最小/最大半径、雨の確率など）

### 主要関数

#### init()
システムの初期化を行います：
- デバイス検出（モバイル/デスクトップ）
- Canvasサイズ設定
- パーティクル/ノード生成

#### resize()
ウィンドウサイズ変更に対応します：
- Canvasサイズを更新
- 描画領域を再設定

#### animate()
メインアニメーションループを実行します：
- 接続線描画
- パーティクル更新・描画
- 次のフレームをリクエスト

#### openModal(data)
モーダルを開いてプロジェクト詳細を表示します：
- テキストのローカライズ
- モーダル要素の更新
- 画像とリンクの設定

#### switchLanguage(lang)
言語を切り替えてUIテキストを更新します：
- 現在の言語を変更
- UIテキストを更新
- 設定を保存

#### applyShockwave(x, y)
指定位置からショックウェーブを発生させます：
- パーティクルを散らす
- 距離に応じた力を適用
- 減衰を有効化

---

## パフォーマンス最適化

### 1. パーティクル数の調整

デバイスに応じてパーティクル数を最適化：

- **デスクトップ**: 80個のパーティクルでリッチな表現
- **モバイル**: 50個に減らしてパフォーマンスを優先

定数 `PARTICLE_COUNT_DESKTOP` と `PARTICLE_COUNT_MOBILE` で管理しています。

### 2. 接続線の最適化

不要な計算を削減：

- 距離チェックで範囲外のパーティクルをスキップ
- バッチ描画でパフォーマンス向上
- 透明度の事前計算

### 3. MediaPipe処理の間引き

フレームごとの処理を間引いてパフォーマンスを向上：

- 3フレームに1回だけ手の検出を実行（約20fps）
- 通常の60fpsで毎フレーム処理する必要はない
- フレームカウンターで処理タイミングを制御

### 4. Canvas最適化

描画処理の最適化：

- `willReadFrequently: false`で読み取り頻度を最適化
- テクスチャの再利用でメモリ効率を向上
- オフスクリーンキャンバスの活用

---

## 今後の拡張可能性

1. **追加のジェスチャー**: より複雑な手の動きの検出（Peace、OK、数字など）
2. **パーティクルエフェクトの追加**: 炎、煙、星、水、魔法陣など
3. **音響効果**: インタラクション時の音声フィードバック
4. **3D効果**: Three.jsやWebGLを使った3Dパーティクルシステム
5. **AI統合**: 表情認識、ポーズ検出、音声認識など

---

## まとめ

このプロジェクトは、モダンなWeb技術を活用したインタラクティブなポートフォリオサイトです。Canvas API、WebGL、MediaPipeを組み合わせることで、ユーザー体験を大幅に向上させています。各ページは独立した機能を持ちながら、統一されたデザイン言語とコード構造で実装されています。

技術的な挑戦と創造性を組み合わせることで、単なる情報提示ではなく、インタラクティブな体験を提供する革新的なWebアプリケーションとなっています。
